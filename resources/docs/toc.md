*Datalevin: The Definitive Guide to Logical and Intelligent Databases*

Part I — Foundations: A Multi-Paradigm Database

1. Why Datalevin: Logic, Graphs, and Key–Value in One Engine

2. Getting Started: Embedded, Server, and Babashka Pod Modes

3. The Datalevin Mental Model: Values, Facts, and Relationships

4. Storage Fundamentals: LMDB, Key–Value Layout, and Persistence

5. Attributes, Entities and Namespaces

Part II — Core APIs: From KV to Datalog

6. Using Datalevin as a Key–Value Store

7. Transactions and Atomic Updates

8. Reading Data: Lookup, Pull, and Entity APIs

9. Datalog Fundamentals: Queries as Logic

10. Rules, Recursion, and Derived Knowledge

Part III — Modeling Across Paradigms

11. Schema Design and Attribute Semantics

12. Relational Modeling Patterns

13. Graph Modeling and Relationship Design

14. Document Modeling and Path-Based Access

15. From Tables to Facts: Migrating from SQL

Part IV — Indexes as Capabilities

16. Core Index Architecture: EAV and AVE

17. Full-Text Search: Analyzers, Vector Space Model and Boolean Search Expression

18. Vector Search: Embeddings and Similarity Queries

19. Automatic Document Indexes and Path Queries

20. Combining Indexes: Hybrid Queries Across KV, Logic, and Search

Part V — Performance and Dataflow

21. Batching, Sorting, and High-Throughput Ingestion

22. Memory Layout and Storage Tuning

23. Query Planning and Optimization

24. Profiling Queries and Understanding Execution

25. Incremental Computation and Semi-Naive Evaluation

Part VI — Systems and Operations

26. Durability, Snapshots, and Backup Strategies

27. Client-Server Architecture: Protocols and Security

28. Encryption at Rest and Security Models

29. Deployment Patterns: Embedded vs Client/Server vs Pods

30. Monitoring, Debugging, and Production Checklist

Part VII — Datalevin for Intelligent Systems

31. Persistent Agent Memory Architectures

32. Apperception Engines and Long-Term State

33. Episodic and Semantic Memory

34. Hybrid Retrieval: Datalog + Full-Text + Vector

35. Building Stateful AI Applications

Part VIII — Internals and Extensions

36. Inside Datalevin: Storage, Indexes, and Execution (with Concurrency & MVCC)

37. Datalog Evaluation Strategies

38. Extending Datalevin: Custom Indexes and Predicates

39. Embedding Datalevin in Applications

40. Contributing to Datalevin and the Ecosystem
